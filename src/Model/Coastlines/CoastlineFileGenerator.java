package Model.Coastlines;

import Enums.FileType;
import Enums.OSMEnums.WayType;
import Helpers.OSDetector;

import View.PopupWindow;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;

import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import javax.swing.*;
import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.ZipInputStream;

/**
 * Class details:
 *
 * @author Andreas Blanke, blan@itu.dk
 * @version 20-03-2017.
 * @project BFST
 */
public final class CoastlineFileGenerator implements ContentHandler {

    private static final String XML_INFO = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
    private static final String OSM_INFO = "<osm version=\"0.6\" " +
            "generator=\"CGImap 0.5.8 (12631 thorn-02.openstreetmap.org)\" " +
            "copyright=\"OpenStreetMap and contributors\" " +
            "attribution=\"http://www.openstreetmap.org/copyright\" " +
            "license=\"http://opendatacommons.org/licenses/odbl/1-0/\">";
    private static final String COMMENT = "<tag k=\"note\" v=\"This a modified osm file " +
            "generated by CoastlineFileGenerator.\"/>";

    private static CoastlineFileGenerator instance;

    private static Map<Long, NodeCarrier> idToNode;
    private static Map<Long, WayCarrier> idToWay;
    private static Map<Long,WayCarrier> coastlines;
    private static Map<Long,NodeCarrier> coastlineNodes;

    private WayCarrier way;
    private WayType wayType;

    private boolean administrative_boundary, admin_level_nation, isMaritime;

    private static double minLatitude, maxLatitude, minLongitude, maxLongitude;

    private static long timer;

    private static final boolean debugging = false;     // change this for more infomation

    private CoastlineFileGenerator() {
        idToNode = new HashMap<>();
        idToWay = new HashMap<>();
        coastlines = new HashMap<>();
        coastlineNodes = new HashMap<>();
        administrative_boundary = false;
        admin_level_nation = false;
    }

    public static CoastlineFileGenerator getInstance() {
        if (instance == null) {
            instance = new CoastlineFileGenerator();
        }
        return instance;
    }

    /**
     * Main method that takes an osm map as a parameter and finds all and any coastlines
     * @param args
     */
    public static void main(String[] args) {
        PopupWindow.infoBox(null,"The function of this program is to load an osm file and discover any " +
                "and all coastlines\n as well as any nation borders on land to create a rough outline " +
                "of the land. \n\nOn the next window please select an osm file.","About this helper");
        JFileChooser fileChooser = PopupWindow.fileLoader(false,null);
        timer = System.currentTimeMillis();
        try {
            if (fileChooser == null) throw new Exception();
            String filename = fileChooser.getSelectedFile().getAbsolutePath();
            if (filename == null) throw new Exception();
            loadOSMFile(filename);
            saveToFile();
        } catch (Exception e) {
            PopupWindow.errorBox(null,"No file selected to open from!");
        }
    }

    private static void loadOSMFile(String fileName) {
        String pathStart = OSDetector.getPathPrefix();

        System.out.println("Loading from file: \""+fileName+"\"\n");

        if(fileName.endsWith(FileType.OSM.getExtension())) {
            loadOSM(new InputSource(pathStart + fileName));
        } else if(fileName.endsWith(FileType.ZIP.getExtension())){
            try {
                ZipInputStream zip = new ZipInputStream(new FileInputStream(fileName));
                try {
                    zip.getNextEntry();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                loadOSM(new InputSource(zip));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        System.out.println("Loading time: "+((System.currentTimeMillis()-timer)/1000)+" s");

        PopupWindow.infoBox(null,"The following file has been loaded:\n\""+fileName+"\"\n into" +
                " the helper which contains "+coastlines.size()+" coastlines.\n\n" +
                "On the next window please select a location and a name for the new osm file.","File loaded");
    }

    private static void loadOSM(InputSource inputSource) {
        try {
            XMLReader reader = XMLReaderFactory.createXMLReader();
            reader.setContentHandler(getInstance());
            reader.parse(inputSource);
        } catch (SAXException | IOException e) {
            e.printStackTrace();
        }
    }

    private static void saveToFile() {
        // @see testCoastlines.osm for inspiration
        Charset charset = Charset.forName("UTF-8");  // unicode encoding

        JFileChooser fileChooser = PopupWindow.fileSaver(false,null);
        timer = System.currentTimeMillis();
        if (fileChooser != null) {
            // retrieves path
            File selectedFile = fileChooser.getSelectedFile();
            String file = selectedFile.getAbsolutePath();
            Path path = Paths.get(file);

            System.out.println("Saving data to file \""+file+"\"\n");

            try (BufferedWriter writer = Files.newBufferedWriter(path, charset)) {
                // header
                writer.write(XML_INFO);
                writer.newLine();
                writer.write(OSM_INFO);
                writer.newLine();
                writer.write(COMMENT);
                writer.newLine();

                // write bounds
                StringBuilder boundsBuilder = new StringBuilder();
                boundsBuilder.append("<bounds minlat=\"");
                boundsBuilder.append(minLatitude);
                boundsBuilder.append("\" minlon=\"");
                boundsBuilder.append(minLongitude);
                boundsBuilder.append("\" maxlat=\"");
                boundsBuilder.append(maxLatitude);
                boundsBuilder.append("\" maxlon=\"");
                boundsBuilder.append(maxLongitude);
                boundsBuilder.append("\"/>");
                writer.write(boundsBuilder.toString());
                writer.newLine(); writer.newLine();

                // write nodes
                for (NodeCarrier node: coastlineNodes.values()) {
                    writer.write(node.toString());
                    writer.newLine();
                }
                writer.newLine();

                // write ways
                for (WayCarrier way: coastlines.values()) {
                    writer.write(way.toString());
                    writer.newLine();
                    if (debugging) System.out.println(way.getInfo());
                }
                writer.newLine();

                // footer
                writer.write("</osm>");

                PopupWindow.infoBox(null,"Coastlines has been saved to \""+file+"\"...\nProgram will now terminate",
                        "File saved...");
            } catch (IOException x) {
                System.err.format("IOException: %s%n", x);
            }

            System.out.println("\n... writing complete ... closing file");
        } else {
            PopupWindow.errorBox(null,"No file selected!");
        }

        System.out.println("Saving time: "+((System.currentTimeMillis()-timer)/1000)+" s");

    }


    @Override
    public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException {
        switch (qName) {
            case "bounds":
                minLatitude = Float.parseFloat(atts.getValue("minlat"));
                maxLatitude = Float.parseFloat(atts.getValue("maxlat"));
                minLongitude = Float.parseFloat(atts.getValue("minlon"));
                maxLongitude = Float.parseFloat(atts.getValue("maxlon"));
                /*  DO NOT CONVERT BOUNDS - OSMHandler will do this when reloading
                float avglat = minLatitude + (maxLatitude - minLatitude)/2;
                longitudeFactor = (float) Math.cos(avglat/180*Math.PI);
                minLongitude *= longitudeFactor;
                maxLongitude *= longitudeFactor;
                minLatitude = -minLatitude;
                maxLatitude = -maxLatitude;
                */
                break;
            case "node":
                long id = Long.parseLong(atts.getValue("id"));
                double latitude = Double.parseDouble(atts.getValue("lat"));
                double longitude = Double.parseDouble(atts.getValue("lon"));
                NodeCarrier node = new NodeCarrier(id, longitude,latitude);
                idToNode.put(id, node); // see OSMHandler for converting
                break;
            case "way":
                id = Long.parseLong(atts.getValue("id"));
                way = new WayCarrier(id);
                idToWay.put(id, way);
                wayType = WayType.UNKNOWN;
                administrative_boundary = false;
                admin_level_nation = false;
                isMaritime = false;
                break;
            case "nd":
                long ref = Long.parseLong(atts.getValue("ref"));
                way.add(idToNode.get(ref));
                break;
            case "tag":
                String k = atts.getValue("k");
                String v = atts.getValue("v");
                switch (k){
                    case "natural":
                        if (v.equals(Coastline.OSM_IDENTIFIER)) {
                            wayType = WayType.COASTLINE;
                        }
                        break;
                    case "boundary":
                        if (v.equals("administrative")) administrative_boundary = true;
                        if (debugging) System.out.println("\"" + v + "\" equals boundary administrative "+v.equals("administrative"));
                        break;
                    case "admin_level":
                        if (v.equals("2")) admin_level_nation = true;
                        if (debugging) System.out.println("\"" + v + "\" equals admin level 2 "+v.equals("2"));
                        break;
                    case "border_type":
                        if (v.equals("nation")) wayType = WayType.COUNTRY_BOUNDARY_LAND;
                        if (debugging) System.out.println("\"" + v + "\" equals border type nation "+v.equals("nation"));
                        break;
                    case "maritime":
                        if (v.equals("yes")) isMaritime = true;
                        if (debugging) System.out.println("\"" + v + "\" equals maritime yes "+v.equals("yes"));
                        break;
                }
                break;
        }
    }

    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {
        if (qName.equals("way")) {
            switch (wayType) {
                case COASTLINE:
                    // coastLineFix();
                    addWay(way);
                    break;
                case COUNTRY_BOUNDARY_LAND:
                    if (debugging) System.out.println("maritime: "+isMaritime+" boundary: "+
                            administrative_boundary+" admin level: "+admin_level_nation);
                    if (!isMaritime && administrative_boundary && admin_level_nation) {
                        // coastLineFix();
                        addWay(way);
                    }   // else ignore
                    break;
            }
        } // else ignore
    }

    private void addWay(WayCarrier way) {
        if (debugging) System.out.println("Added way... Total: "+coastlines.size());
        way.putCoastlineTag();
        coastlines.put(way.ref,way);
        coastlineNodes.putAll(way.getMap());
    }

    @Override
    public void setDocumentLocator(Locator locator) {}

    @Override
    public void startDocument() throws SAXException {}

    @Override
    public void endDocument() throws SAXException {}

    @Override
    public void startPrefixMapping(String prefix, String uri) throws SAXException {}

    @Override
    public void endPrefixMapping(String prefix) throws SAXException {}

    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {}

    @Override
    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {}

    @Override
    public void processingInstruction(String target, String data) throws SAXException {}

    @Override
    public void skippedEntity(String name) throws SAXException {}

    /* --------------- INTERNAL CLASSES - DO NOT USE OUTSIDE THIS CLASS --------------- */
    public static class NodeCarrier {
        long ref;
        double lat, lon;

        public NodeCarrier(long ref, double longitude, double latitude) {
            this.ref = ref;
            lon = longitude;
            lat = latitude;
        }

        @Override
        public String toString() {
            return "<node id=\""+ ref +"\" " +
                    "lat=\""+lat+"\" lon=\""+lon+"\"/>";
        }
    }

    public static class WayCarrier extends ArrayList<NodeCarrier> {
        private long ref;
        private Map<String,String> tags;

        public WayCarrier(long ref) {
            this.ref = ref;
            tags = new HashMap<>();
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("<way id=\"");
            sb.append(ref);
            sb.append("\">");

            // add node references
            for (NodeCarrier node: this) {
                sb.append("<nd ref=\"");
                sb.append(node.ref);
                sb.append("\"/>");
            }

            // add tags
            for (String key: tags.keySet()) {
                sb.append("<tag k=\"");
                sb.append(key);
                sb.append("\" v=\"");
                sb.append(tags.get(key));
                sb.append("\"/>");
            }

            // end
            sb.append("</way>");
            return sb.toString();
        }

        private NodeCarrier getFromNode() {
            return get(0);
        }

        private NodeCarrier getToNode() {
            return get(size()-1);
        }

        private Map<Long,NodeCarrier> getMap() {
            Map<Long,NodeCarrier> map = new HashMap<>();
            for (NodeCarrier node: this) {
                map.put(node.ref,node);
            }
            return map;
        }

        private void putCoastlineTag() {
            tags.put("natural","coastline");
        }

        private String getInfo() {
            StringBuilder sb = new StringBuilder();
            sb.append("Way: ");
            sb.append(ref);
            sb.append(" contains ");
            sb.append(this.size());
            sb.append(" number of elements.\n Nodes (ref): ");
            for (NodeCarrier node: this) {
                sb.append("\n ... ");
                sb.append(node.ref);
            }
            sb.append("\n Tags:");
            if (tags.isEmpty()) sb.append("N/A");
            for (String key: tags.keySet()) {
                sb.append("\n ... k=\"");
                sb.append(key);
                sb.append("\" v=\"");
                sb.append(tags.get(key));
                sb.append("\"");
            }
            return sb.toString();
        }
    }

    public void resetInstance() {
        instance = null;
    }
}
